name: Master Pipeline

on:
  push:
    branches: [ "main", "gitactions" ]
  pull_request:
    branches: [ "main", "gitactions" ]

jobs:
  # scans for secrets in the repository, revealing vulnerabilities
  secrets-scan:
    name: Detect Secrets in Code
    runs-on: ubuntu-latest

    steps:
      # checkout code
      - name: Checkout Code
        uses: actions/checkout@v3

      # install gitleaks
      - name: Download and install gitleaks
        run: |
          cd /tmp
          sudo wget -q \
            "https://github.com/zricethezav/gitleaks/releases/download/v${GITLEAKS_VERSION}/gitleaks_${GITLEAKS_VERSION}_linux_x64.tar.gz" \
            -O gitleaks.tar.gz || \
            (echo "Error downloading gitleaks ${GITLEAKS_VERSION} tarball" && exit 1)
          sudo tar -xvzf gitleaks.tar.gz || \
            (echo "Error unarchiving gitleaks ${GITLEAKS_VERSION} tarball" && exit 1)
          sudo mv gitleaks /usr/bin/. || \
            (echo "Error moving gitleaks for /usr/bin" && exit 1)
        shell: bash
        env:
          GITLEAKS_VERSION: "8.18.1"

      # runs gitleaks
      - name: Run gitleaks
        run: gitleaks -v detect --no-git ${{ secrets.GITHUB_TOKEN }} --source . --redact --exit-code 0
        shell: bash

  # lints codebase, checking for syntax and formatting errors
  lint:
    name: Lint Codebase
    runs-on: ubuntu-latest
    needs: ["secrets-scan"]
    steps:
      # checkout code
      - name: Checkout Code
        uses: actions/checkout@v2

      # runs super-linter
      - name: Run Super-Linter
        uses: github/super-linter@v5
        env:
          DEFAULT_BRANCH: main
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VALIDATE_ALL_CODEBASE: false

          # paths to lint
          FILE_PATHS: |-
            frontend/src/
            frontend/Dockerfile
            backend/src/
            backend/Dockerfile
            infrastructure/
            tests/

          # file types to validate
          FILE_TYPES: |-
            java
            yaml
            dockerfile
            env
            svelte
            javascript
            typescript
            css
            html
            json
            terraform
            hcl

  # runs unit tests for the frontend
  frontend-unit-tests:
    name: Unit Tests Frontend
    runs-on: ubuntu-latest
    needs: ["lint"]
    steps:
      # checkout code
      - name: Checkout Code
        uses: actions/checkout@v3

      # setting up node.js
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "18"

      # caching node.js modules (for faster runs)
      - name: Cache Node.js modules
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      # installing dependencies
      - name: Install Dependencies
        run: |
          cd frontend
          npm install

      # running tests
      - name: Run Tests
        run: |
          cd frontend
          npm test

  # runs unit tests for the backend
  backend-unit-tests:
    name: Unit Tests Backend
    runs-on: ubuntu-latest
    needs: ["lint"]
    steps:
      # checkout code
      - name: Checkout Code
        uses: actions/checkout@v3

      # setting up java
      - name: Set up Java
        uses: actions/setup-java@v3
        with:
          java-version: "17"
          distribution: "adopt"

      # caching maven files (for faster runs)
      - name: Cache Maven repository
        uses: actions/cache@v3
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      # installing dependencies
      - name: Install Dependencies
        run: |
          cd backend
          mvn dependency:resolve

      # running tests
      - name: Run Tests
        run: |
          cd backend
          mvn test

  # builds, scans, and pushes docker containers
  build-scan-and-push-containers:
    name: Build, Scan and Push Containers
    runs-on: ubuntu-latest
    needs: ["frontend-unit-tests", "backend-unit-tests"]
    steps:
      # checkout the code
      - name: Checkout code
        uses: actions/checkout@v3

      # log in to docker hub
      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # builds the svelte frontend container image
      - name: Build Svelte app container
        run: |
          docker build -t osklot12/svelte-frontend:latest ./frontend

      # builds the spring backend container image
      - name: Build Spring Boot backend image
        run: |
          docker build -t osklot12/spring-backend:latest ./backend

      # scans the svelte app for vulnerabilities
      - name: Scan Svelte app container
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: osklot12/svelte-frontend:latest

      # scans the spring app for vulnerabilities
      - name: Scan Spring Boot backend container
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: osklot12/spring-backend:latest

      # pushes the svelte docker image
      - name: Push Svelte frontend Docker image
        run: |
          docker push osklot12/svelte-frontend:latest

      # pushes the spring docker image
      - name: Push Spring backend Docker image
        run: |
          docker push osklot12/spring-backend:latest

  # validates and initializes production infrastructure
  validate-and-initialize-production-infrastructure:
    name: Validates and Initializes Production Infrastructure
    runs-on: ubuntu-latest
    needs: ["build-scan-and-push-containers"]
    steps:
      # checkout code
      - name: Checkout code
        uses: actions/checkout@v3

      # authenticates to google cloud
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS }}

      # setting up google cloud sdk
      - name: Set up Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v1
        with:
          version: "latest"
          project_id: "idata2502-ci-cd"

      # setting up terraform
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.4.5

      # initializing terraform
      - name: Terraform Init
        run: terraform init
        working-directory: infrastructure/terraform/prod/

      # refreshing terraform
      - name: Terraform Refresh
        run: terraform refresh
        working-directory: infrastructure/terraform/prod

      # planning infrastructure changes
      - name: Terraform Plan
        run: terraform plan
        working-directory: infrastructure/terraform/prod

      # applying infrastructure changes
      - name: Terraform Apply
        run: terraform apply
        working-directory: infrastructure/terraform/prod

  # validates and initializes test infrastructure
  validate-and-initialize-test-infrastructure:
    name: Validates and Initializes Test Environment
    runs-on: ubuntu-latest
    needs: ["build-scan-and-push-containers"]
    steps:
      # checkout code
      - name: Checkout code
        uses: actions/checkout@v3

      # authenticates to google cloud
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS }}

      # setting up google cloud sdk
      - name: Set up Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v1
        with:
          version: "latest"
          project_id: "idata2502-ci-cd"

      # setting up terraform
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.4.5

      # initializing terraform
      - name: Terraform Init
        run: terraform init
        working-directory: infrastructure/terraform/test/

      # refreshing terraform
      - name: Terraform Refresh
        run: terraform refresh
        working-directory: infrastructure/terraform/test

      # planning infrastructure changes
      - name: Terraform Plan
        run: terraform plan
        working-directory: infrastructure/terraform/test

      # applying infrastructure changes
      - name: Terraform Apply
        run: terraform apply
        working-directory: infrastructure/terraform/test

  # setting up test environment
  setup-test-environment:
    name: Setup Test Environment
    runs-on: ubuntu-latest
    needs: ["validate-and-initialize-production-infrastructure", "validate-and-initialize-test-infrastructure"]
    steps:
      # checkout code
      - name: Checkout Repository
        uses: actions/checkout@v3

      # authenticates to google cloud
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS }}

      # setting up google cloud sdk
      - name: Set up Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v1
        with:
          version: "latest"

      # installing gke-gcloud-auth-plugin
      - name: Install gke-gcloud-auth-plugin
        run: |
          gcloud components install gke-gcloud-auth-plugin --quiet
          gcloud components update --quiet 

      # setting up kubernetes kubectl
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      # setting kubernetes context for text environment
      - name: Set Kubernetes Context
        run: |
          gcloud container clusters get-credentials tomorrow-cluster-test --region europe-north1 --project idata2502-project

      - name: Create Test Namespace
        id: create_namespace
        run: |
          export NAMESPACE="test-env-${{ github.run_id }}"
          echo "NAMESPACE=$NAMESPACE" >> $GITHUB_ENV
          kubectl create namespace $NAMESPACE

      # applying kubernetes manifest files
      - name: Apply Kubernetes Manifests
        run: |
          kubectl apply -n $NAMESPACE -f infrastructure/k8s/test/storage
          kubectl apply -n $NAMESPACE -f infrastructure/k8s/test/secrets
          kubectl apply -n $NAMESPACE -f infrastructure/k8s/test/db
          kubectl apply -n $NAMESPACE -f infrastructure/k8s/test/backend
          kubectl apply -n $NAMESPACE -f infrastructure/k8s/test/frontend

      # waiting for deployment to roll out
      - name: Wait for Deployments to Roll Out
        run: |
          kubectl rollout status deployment/backend-deployment -n $NAMESPACE --timeout=300s
          kubectl rollout status deployment/frontend-deployment -n $NAMESPACE --timeout=300s

      # ensuring all pods are ready
      - name: Wait for All Pods to Be Ready
        run: |
          kubectl wait --for=condition=Ready pods -l app=backend -n $NAMESPACE --timeout=300s
          kubectl wait --for=condition=Ready pods -l app=frontend -n $NAMESPACE --timeout=300s
          kubectl wait --for=condition=Ready pods -l app=postgres -n $NAMESPACE --timeout=300s

      # resetting database
      - name: Reset Database
        run: |
          kubectl delete job reset-database || true
          kubectl apply -n $NAMESPACE -f infrastructure/k8s/test/jobs/reset-database.yaml
          kubectl wait --for=condition=complete job/reset-database -n $NAMESPACE --timeout=120s

      # outputting kubernetes resource status
      - name: Output Kubernetes Status
        run: |
          kubectl get all -n $NAMESPACE

  # running integration (postman) tests
  postman-tests:
    name: Postman Tests
    runs-on: ubuntu-latest
    needs: ["setup-test-environment"]
    steps:
      # checkout code
      - name: Checkout Code
        uses: actions/checkout@v3

      # setup node.js
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'

      # install newman
      - name: Install Newman
        run: npm install -g newman

      # run postman collection
      - name: Run Postman Tests
        run: newman run tests/postman/api_integration_tests.postman_collection.json

  # running e2e (cypress) tests
  cypress-tests:
    name: Cypress Tests
    runs-on: ubuntu-latest
    needs: ["setup-test-environment"]
    steps:
      # checkout code
      - name: Checkout code
        uses: actions/checkout@v3

      # setup node.js
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "18"

      # installing dependencies
      - name: Install dependencies
        run: npm install cypress --save-dev
        working-directory: tests/cypress

      # running cypress tests
      - name: Run Cypress tests
        run: npx cypress run --browser chrome
        working-directory: tests/cypress

  # Runs function to tag successfull commits
  tag-successful-commit:
    name: Successful tag
    needs: ["cypress-tests", "postman-tests", "lint"]
    runs-on: ubuntu-latest

    steps:
    # Checkout code
    - name: Checkout code
      uses: actions/checkout@v3

      # Tags commit as "successfull-(date of commit)"
    - name: Tag successful commit
      run: |
          TAG_NAME="successful-$(date +'%Y%m%d%H%M%S')"
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git tag $TAG_NAME
          git push origin $TAG_NAME

  # tags the images as stable
  tag-stable-images:
    name: Tag and Push Stable Images
    runs-on: ubuntu-latest
    needs: ["postman-tests", "cypress-tests"]
    steps:
      # checkout code
      - name: Checkout code
        uses: actions/checkout@v3

      # log in to docker hub
      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # tags and pushes stable frontend image
      - name: Tag and Push Stable Svelte Frontend
        run: |
          docker pull osklot12/svelte-frontend:latest
          docker tag osklot12/svelte-frontend:latest osklot12/svelte-frontend:stable
          docker push osklot12/svelte-frontend:stable

      # tags and pushes stable backend image
      - name: Tag and Push Stable Spring Backend
        run: |
          docker pull osklot12/spring-backend:latest
          docker tag osklot12/spring-backend:latest osklot12/spring-backend:stable
          docker push osklot12/spring-backend:stable

  # cleaning up test environment
  cleanup-test-environment:
    name: Cleanup Test Environment
    runs-on: ubuntu-latest
    needs: ["postman-tests", "cypress-tests"]
    steps:
      # checkout code
      - name: Checkout Repository
        uses: actions/checkout@v3

      # authenticates to google cloud
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS }}

      # setting up google cloud sdk
      - name: Set up Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v1
        with:
          version: "latest"

      # installing gke-gcloud-auth-plugin
      - name: Install gke-gcloud-auth-plugin
        run: |
          gcloud components install gke-gcloud-auth-plugin --quiet
          gcloud components update --quiet 

      # setting up kubernetes kubectl
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      # setting kubernetes context for test environment
      - name: Set Kubernetes Context
        run: |
          gcloud container clusters get-credentials tomorrow-cluster-test --region europe-north1 --project idata2502-project

      # cleaning up test resources
      - name: Reset Kubernetes Resources
        run: |
          kubectl delete namespace $NAMESPACE || true

  # setting up production environment
  setup-production-environment:
    name: Setup Production Environment
    runs-on: ubuntu-latest
    needs: ["tag-stable-images"]
    steps:
      # checkout code
      - name: Checkout Repository
        uses: actions/checkout@v3

      # authenticates to google cloud
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS }}

      # setting up google cloud sdk
      - name: Set up Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v1
        with:
          version: "latest"

      # installing gke-gcloud-auth-plugin
      - name: Install gke-gcloud-auth-plugin
        run: |
          gcloud components install gke-gcloud-auth-plugin --quiet
          gcloud components update --quiet

      # setting up kubernetes kubectl
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      # setting kubernetes context for production environment
      - name: Set Kubernetes Context
        run: |
          gcloud container clusters get-credentials tomorrow-cluster-prod --region europe-north1 --project idata2502-project

      # applying kubernetes manifest files
      - name: Apply Kubernetes Manifests
        run: |
          kubectl apply -f infrastructure/k8s/prod/storage
          kubectl apply -f infrastructure/k8s/prod/secrets
          kubectl apply -f infrastructure/k8s/prod/db
          kubectl apply -f infrastructure/k8s/prod/backend
          kubectl apply -f infrastructure/k8s/prod/frontend

      # waiting for deployments to roll out
      - name: Wait for Deployments to Roll Out
        run: |
          kubectl rollout status deployment/backend-deployment --timeout=300s
          kubectl rollout status deployment/frontend-deployment --timeout=300s

      # verifying all pods are ready
      - name: Wait for All Pods to Be Ready
        run: |
          kubectl wait --for=condition=Ready pods -l app=backend --timeout=300s
          kubectl wait --for=condition=Ready pods -l app=frontend --timeout=300s
          kubectl wait --for=condition=Ready pods -l app=postgres --timeout=300s

      # outputting kubernetes resource status
      - name: Output Kubernetes Status
        run: |
          kubectl get all

  revert-main:
    # Depend on tag-successfull-commit and always run if it fails
    needs: ["tag-successful-commit"]
    if: ${{ failure() }} # Run this job if spesified previous jobs failed
    runs-on: ubuntu-latest

    steps:
      # Checkout code
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}

      # Fetch code
      - name: Fetch tags
        run: git fetch --tags
        
      # Scans for last commit with the "successful-(date)" tag
      - name: Find the last successful tag
        id: find_tag
        run: |
          LAST_TAG=$(git describe --tags $(git rev-list --tags --max-count=1))
          echo "Found last successful tag: $LAST_TAG"
          echo "last_successful_tag=$LAST_TAG" >> $GITHUB_ENV
          echo "::set-output name=last_tag::$LAST_TAG"
        
      # resets the files to the last commit while excluding .github/workflow
      - name: Reset all except workflow files
        run: |
          if [ -z "${{ steps.find_tag.outputs.last_tag }}" ]; then
            echo "No successful tag found. Exiting."
            exit 1
          fi

          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

          # Create a list of changed files, excluding .github/workflows
          changed_files=$(git diff --name-only ${{ steps.find_tag.outputs.last_tag }} HEAD | grep -v '^\.github/workflows/')

          if [ -z "$changed_files" ]; then
            echo "No files to reset."
            exit 0
          fi

          echo "$changed_files" | while read file; do
            git checkout ${{ steps.find_tag.outputs.last_tag }} -- "$file"
          done

          git add .
          git commit -m "Reverted changes to ${{ steps.find_tag.outputs.last_tag }} excluding workflow files"

          current_branch=$(git rev-parse --abbrev-ref HEAD)
          echo "Pushing to branch: $current_branch"
          git push origin "$current_branch" --force
